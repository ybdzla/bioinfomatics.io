# 8.1)
```r
# 1. 加载所需 R 包
install.packages("glmnet")
library(caret)
library(pROC)
library(glmnet)
library(ggplot2)


# 2. 数据读取与预处理
# 读取数据
data <- read.csv("qPCR_data.csv")

# 提取特征和标签
x <- data[, 2:12]
y <- as.factor(data[, 13])  # 标签列：NC / HCC

# 清洗列名（防止非法字符）
colnames(x) <- make.names(colnames(x))

# 转为数值型 + 缺失值填补（均值）
x <- apply(x, 2, as.numeric)
feature.mean <- colMeans(x, na.rm = TRUE)
x[is.na(x)] <- matrix(rep(feature.mean, each = nrow(x)), nrow = nrow(x))[is.na(x)]

# Z-score 标准化
x <- scale(x, center = TRUE, scale = TRUE)

# 3.PCA可视化
pca.res <- prcomp(x, center = TRUE, scale. = TRUE)
pca.df <- data.frame(pca.res$x[, 1:2], label = y)

ggplot(pca.df, aes(x = PC1, y = PC2, color = label)) +
  geom_point(size = 3) +
  labs(title = "PCA of qPCR data", x = "PC1", y = "PC2") +
  theme_minimal()

# 4.数据集划分（80%训练集，20%测试集）
set.seed(666)
train.idx <- createDataPartition(y, p = 0.8, list = FALSE)
x.train <- x[train.idx, ]
x.test  <- x[-train.idx, ]
y.train <- y[train.idx]
y.test  <- y[-train.idx]

# 5.特征选用（使用RFE）
lrFuncs$summary <- twoClassSummary
ctrl <- rfeControl(functions = lrFuncs, method = "boot", number = 10, verbose = TRUE)

rfe.res <- rfe(x.train, y.train, sizes = 2:11, rfeControl = ctrl, metric = "ROC")
selected.vars <- predictors(rfe.res)
selected.vars  # 输出被选中的变量

# 6.模型训练 + 超参数调优（逻辑回归）
params.grid <- expand.grid(alpha = c(0, 0.5, 1), lambda = c(0.01, 0.1, 1))

tr.ctrl <- trainControl(method = "cv", number = 5,
                        summaryFunction = twoClassSummary,
                        classProbs = TRUE)

cv.fit <- train(x.train[, selected.vars], y.train,
                method = "glmnet",
                family = "binomial",
                metric = "ROC",
                tuneGrid = params.grid,
                trControl = tr.ctrl)

cv.fit$bestTune  # 查看最优参数

# 7.模型评估
y.prob <- predict(cv.fit, newdata = x.test[, selected.vars], type = "prob")[, "HCC"]
roc.curve <- roc(y.test, y.prob, levels = rev(levels(y.test)))

plot(roc.curve, print.auc = TRUE, main = "ROC Curve for qPCR Classification")
```

